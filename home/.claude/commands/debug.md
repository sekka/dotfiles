---
description: エラーの原因調査と修正提案
argument-hint: [エラーメッセージまたは問題の説明]
---

# デバッグ

問題: $ARGUMENTS

## 実行内容

### Step 1: 情報収集

#### エラーメッセージの解析

- エラータイプ（TypeError, SyntaxError, NetworkError 等）
- スタックトレースの確認
- 発生箇所の特定

#### 再現条件の確認と最小再現ケースの作成

- どの操作で発生するか
- 発生頻度（常に/時々/特定条件下）
- 環境依存性（開発/本番、ブラウザ/Node.js、特定のユーザー/データ）
- **再現手順を明確に記録**（ステップバイステップ）
- **最小再現ケースの作成**（問題を再現する最小限のコード/手順）

#### ログ・トレース・メトリクスの収集

- アプリケーションログの確認
- エラートラッキングサービス（Sentry等）の確認
- サーバーログ、データベースログの確認
- パフォーマンスメトリクス（レスポンス時間、メモリ使用量等）
- 分散トレーシング（マイクロサービスの場合）

#### 影響範囲の評価

- 影響を受けるユーザー数/割合
- 発生頻度（回/日、回/時間）
- ビジネスへの影響度（重大/中/軽微）
- データ損失や不整合のリスク

### Step 2: 既知問題の確認

- 過去に同様のエラーが報告されていないか確認
- 最近のコード変更やデプロイとの関連を確認
- 外部サービスの障害情報を確認
- 依存ライブラリの既知の問題を確認

### Step 3: 仮説の立案

考えられる原因を列挙し、優先順位をつける：

```markdown
| #   | 仮説 | 可能性   | 検証方法 | 根拠 |
| --- | ---- | -------- | -------- | ---- |
| 1   | ...  | 高/中/低 | ...      | ...  |
```

### Step 4: 検証

仮説を可能性の高いものから順に検証：

1. 関連するコードを読む
2. ログを追加して状態を確認
3. デバッガーでステップ実行
4. 最小再現コードを作成
5. 必要に応じて追加の計測ポイントを設置

**追加で取得すべき情報：**

- 不足しているログやメトリクスがあれば指摘
- デバッグ情報の収集方法を提案
- 必要に応じてモニタリングの改善を提案

### Step 5: 根本原因の特定

- **直接的な原因**: 何が問題を引き起こしたか
- **根本的な原因**: なぜその状態になったか（5 Whys分析）
- **類似の問題**: 他にも同じパターンがないか確認
- **回帰の可能性**: 過去に修正したが再発していないか確認

### Step 6: 修正提案

```markdown
## 修正案

### 原因

- 直接的な原因: ...
- 根本的な原因: ...

### 回避策（緊急対応）

**優先度**: 高/中/低
**実施時間**: X分/時間
**リスク**: 低/中/高

...

### 恒久対策

**優先度**: 高/中/低
**実施時間**: X時間/日
**リスク**: 低/中/高

...

### 影響範囲

- 変更するファイル: ...
- 影響を受ける機能: ...
- データ移行の必要性: ...
- ダウンタイムの必要性: ...

### 再発防止策

- 追加すべきテスト: ...
- 追加すべきログ/メトリクス: ...
- コードレビューでのチェック項目: ...
- 監視アラートの設定: ...
```

### Step 7: 修正と検証（承認後）

1. 修正を実装（回避策 or 恒久対策）
2. **再現テストで問題が解決したことを確認**
3. 関連するテストを追加（回帰防止）
4. 既存テストがパスすることを確認
5. 必要に応じてモニタリング・アラートを設定
6. 修正内容をドキュメント化

## デバッグテクニック

### ログ出力

```typescript
// 状態の確認
console.log("変数名:", JSON.stringify(変数, null, 2));

// タイミングの確認
console.time("処理名");
// ...処理...
console.timeEnd("処理名");

// スタックトレース
console.trace("ここまでの呼び出し");
```

### 分割統治法

1. 問題が発生する範囲を半分に絞る
2. どちらで問題が発生するか確認
3. 繰り返して原因箇所を特定

### 差分デバッグ

- 正常に動作していた時点のコードと比較
- `git bisect` で問題が混入したコミットを特定

### ラバーダック・デバッグ

- 問題を言語化して説明する
- 説明する過程で気づきを得る

## よくある原因

### JavaScript/TypeScript

- `null`/`undefined` へのアクセス
- 非同期処理の順序
- スコープの問題（クロージャ、this）
- 型の不一致
- 配列/オブジェクトの参照

### React

- 無限レンダリングループ
- 依存配列の不足
- 状態の非同期更新
- キーの重複/欠落

### ネットワーク

- CORS エラー
- 認証/認可の問題
- タイムアウト
- レスポンス形式の不一致

## デバッグの原則

1. **再現性と証拠に基づく**
   - 推測で修正せず、確実に原因を特定してから修正
   - 再現手順を明確に記録
   - ログやトレースで証拠を収集

2. **回避策と恒久対策を区別**
   - 緊急時は回避策で一時対応
   - 後で必ず恒久対策を実施
   - 回避策のままで放置しない

3. **影響範囲を最小化**
   - 修正の影響範囲を明確にする
   - リスクの高い変更は慎重に
   - 必要に応じて段階的にロールアウト

4. **再発防止を徹底**
   - テストを追加して回帰を防ぐ
   - 監視・アラートで早期検出
   - ドキュメント化して知識を共有

5. **復旧までの最短経路を示す**
   - 緊急度に応じて回避策を優先
   - ロールバック手順も準備
   - ダウンタイムを最小化

## 注意事項

- 推測で修正せず、原因を特定してから修正
- 修正後は必ず再現テストを行う
- デバッグ用のコード（console.log 等）は最終的に削除
- 根本原因を修正し、対症療法に頼らない
- 本番環境での調査は慎重に（パフォーマンス影響を考慮）
- セキュリティインシデントの可能性がある場合は専門チームに相談
