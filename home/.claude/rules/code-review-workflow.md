# コード実装のワークフロー

## 概要

コードの品質を高めるため、以下の段階的なワークフローを推奨する。
適切なツールを適切なタイミングで使うことで、効率的かつ高品質な実装を実現する。

---

## 実装の4段階アプローチ

### 0. 開始前：要件の明確化（AskUserQuestion）

#### 使用ツール

`AskUserQuestion`

#### 目的

- 曖昧な要件を明確化
- 優先順位の確認
- 制約条件の把握

#### タイミング

- ユーザーのリクエストが曖昧な場合
- 実装前に必ず実施
- Planモードでも最初にヒアリング

#### 注意事項

- **自明な質問は避ける**
  - NG: "良いコードを書きたいですか？"
  - OK: "パフォーマンスと可読性、どちらを優先しますか？"
- **ユーザー自身が言語化していない前提を引き出す**
  - 例: 納期、チームスキル、既存システムとの互換性

#### 実例

```typescript
AskUserQuestion({
  question: "認証方式を選択してください",
  choices: [
    "JWT（ステートレス、スケーラブル）",
    "Session（セキュア、実装簡単）",
    "OAuth（サードパーティ連携必要）"
  ],
  multiSelect: false
});
```

---

### 1. 実装前：設計方針の相談

#### 使用ツール

`/ask-peer` スキル

#### 目的

- 設計判断
- アーキテクチャ選択
- トレードオフ評価

#### タイミング

- 実装を開始する前
- 複数のアプローチで迷ったとき
- 大きな設計変更を伴う場合

#### 注意事項

- **Peerの意見を鵜呑みにしない**
  - 複数の視点（Main Claude、Peer、ユーザー）を総合的に評価
- **内部でAskUserQuestionが使用される**
  - Peerが不明点をユーザーに確認する

#### 実例

```
シナリオ: REST API vs GraphQLで迷っている

1. /ask-peer を起動
2. Peerが設計案を複数提示
3. Peerがトレードオフを説明
4. Peerが推奨案を提示
5. ユーザーが最終決定
```

---

### 2. 実装中：リアルタイムチェック

#### 使用ツール

`/reviewing-with-claude` スキル

#### 目的

- コーディング中の軽微な確認
- セキュリティチェック
- コーディング規約違反の検出

#### タイミング

- 実装中、随時
- 不安な箇所がある場合
- セキュリティ上重要な箇所

#### 注意事項

- **小規模な変更向け**
  - 大規模な変更は `/reviewing-parallel` を使う
- **現在のセッションコンテキストを活用**
  - 会話履歴を参照するため、文脈を理解している

#### 実例

```typescript
// パスワードハッシュ化のコード
const hashedPassword = crypto
  .createHash('md5')  // ← この行が不安
  .update(password)
  .digest('hex');

// /reviewing-with-claude を実行
// → "MD5は脆弱。bcryptを使うべき" と指摘
```

---

### 3. 実装後：包括的レビュー

#### 使用ツール

`/reviewing-parallel` スキル

#### 目的

- 複数AI（Codex、CodeRabbit、Copilot、Gemini）による多角的な品質評価
- セキュリティ、パフォーマンス、保守性の総合チェック
- 重複指摘の排除と優先度付け

#### タイミング

- 実装完了後
- PR作成前
- 重要な変更がある場合

#### 注意事項

- **4つのAI並列実行のため時間がかかる**
  - 軽微な変更には `/reviewing-with-claude` を使う
- **重要な変更に使用**
  - 例: セキュリティクリティカルな機能、パフォーマンス重視の機能

#### 実例

```
シナリオ: 決済処理の実装完了

1. /reviewing-parallel を起動
2. Codex: SQLインジェクション脆弱性を指摘
3. CodeRabbit: トランザクション境界の問題を指摘
4. Copilot: エラーハンドリング不足を指摘
5. Gemini: ログ出力に機密情報が含まれると指摘
6. 統合レポート生成（重複排除、優先度付け）
```

---

## ワークフロー判断ツリー

```
実装タスク開始
  ↓
ユーザーのリクエストは明確？
  NO  → AskUserQuestionで要件明確化
  YES → 次へ
  ↓
設計判断が必要？
  YES → /ask-peer で相談 → 方針決定
  NO  → 直接実装開始
  ↓
実装実行
  ↓（随時）
不安な箇所がある？
  YES → /reviewing-with-claude で確認
  NO  → 実装継続
  ↓
実装完了
  ↓
重要な変更？
  YES → /reviewing-parallel で包括レビュー
  NO  → /reviewing-with-claude で軽量レビュー
  ↓
コミット・PR作成
```

---

## AI相談の原則

複数のAI（Peer、Reviewer等）を活用する際の原則：

### 1. 鵜呑みにしない

- AIの提案を無批判に受け入れず、常に検証する
- 特にセキュリティ・パフォーマンスに関わる提案は要注意

**例:**

```
AI提案: "このコードは遅いのでキャッシュを使いましょう"

検証すべき点:
- 本当に遅いのか？計測したか？
- キャッシュの無効化戦略は？
- メモリ使用量は許容範囲か？
```

### 2. 複数視点の統合

- Main Claude、Peer、外部Reviewer、ユーザー自身の判断を総合評価
- 1つの視点だけで判断しない

**例:**

```
Main Claude: "シンプルにRESTで十分"
Peer: "将来の拡張性を考えるとGraphQL"
ユーザー: "チームにGraphQLの知見がない"

→ 結論: RESTを選択（チームスキルを優先）
```

### 3. 適材適所

- 軽微な判断に重量級ツールを使わない（コスト・時間の無駄）

**適切な選択:**

| 変更規模 | ツール |
|---------|--------|
| 1-2行の修正 | /reviewing-with-claude |
| 関数1つの追加 | /reviewing-with-claude |
| モジュール全体の変更 | /reviewing-parallel |
| セキュリティクリティカル | /reviewing-parallel |

### 4. 最終判断は人間

- AIはあくまで補助
- 責任ある判断はユーザーが行う
- AIが「推奨」と言っても、状況次第で却下してOK

---

## AskUserQuestionの使用方針

Claude Codeは`AskUserQuestion`ツールを使い、ユーザーに選択肢形式で質問できる。これを積極的に活用すること。

### 使用すべき場面

#### 1. 曖昧な要件

**例:**

```
ユーザー: "パフォーマンスを改善して"

質問: "何を優先しますか？"
選択肢:
- メモリ使用量の削減
- 実行速度の向上
- 起動時間の短縮
```

#### 2. 優先順位の確認

**例:**

```
ユーザー: "フォームを実装して"

質問: "トレードオフがあります。どちらを優先？"
選択肢:
- パフォーマンス（バリデーションは最小限）
- UX（リアルタイムバリデーション、丁寧なエラー表示）
```

#### 3. 制約条件の把握

**例:**

```
ユーザー: "この機能を追加して"

質問: "納期はどれくらいですか？"
選択肢:
- 今日中（最小限の実装）
- 1週間以内（テスト込み）
- 2週間以上（品質重視）
```

#### 4. 最終判断の委譲

**例:**

```
質問: "2つのアプローチがあります"
選択肢:
- オプションA（推奨）: シンプル、保守しやすい、パフォーマンスはやや劣る
- オプションB: 高速、複雑、保守コスト高
```

### 効果的な質問の条件

#### 選択肢は2-4個

- 多すぎると選択負担が増える
- 2-4個がベスト

#### 自明でない

**NG:**

```
質問: "良いコードを書きたいですか？"
選択肢: [はい, いいえ]
```

**OK:**

```
質問: "コードの方針を選んでください"
選択肢:
- 速度優先（複雑でも速く）
- 可読性優先（遅くても分かりやすく）
- バランス型
```

#### 具体的

- ユーザーが判断できる具体性を持つ
- 専門用語だけでなく、影響を説明する

**NG:**

```
選択肢: "Monad transformerを使う"
```

**OK:**

```
選択肢: "エラーハンドリングを関数型スタイルで実装（学習コスト高）"
```

#### multiSelect活用

- 複数選択が適切な場合は `multiSelect: true` を使用

**例:**

```typescript
AskUserQuestion({
  question: "どの機能を実装しますか？（複数選択可）",
  choices: [
    "ユーザー認証",
    "メール通知",
    "ファイルアップロード",
    "検索機能"
  ],
  multiSelect: true
});
```

### 避けるべき質問

#### 専門的すぎてユーザーが答えられない質問

**NG:**

```
質問: "Monoidal categoryとApplicative functorどちらを使いますか？"
```

#### はい/いいえだけで答えられる単純な質問

**NG:**

```
質問: "TypeScriptを使いますか？"
選択肢: [はい, いいえ]
```

**OK:**

```
質問: "型安全性の方針を選んでください"
選択肢:
- TypeScript（型安全、学習コスト高）
- JavaScript + JSDoc（柔軟、型安全性は低い）
- JavaScript（最速、型チェックなし）
```

#### AIが自分で判断できる技術的詳細

**NG:**

```
質問: "変数名はcamelCaseとsnake_caseどちらがいいですか？"
→ これはコーディング規約で決まっているはず
```

---

## 実践例

### シナリオ: REST API実装

#### Step 0: 要件明確化

```typescript
AskUserQuestion({
  question: "APIの認証方式を選んでください",
  choices: [
    "JWT（ステートレス、スケーラブル）",
    "Session（セキュア、実装簡単）",
    "API Key（シンプル、セキュリティ低）"
  ]
});

→ ユーザーが "JWT" を選択
```

#### Step 1: 設計相談

```
/ask-peer を起動

Peer提案:
- Option A: JWT + Redis（高速、複雑）
- Option B: JWT + DB（シンプル、やや遅い）

→ ユーザーが Option B を選択
```

#### Step 2: 実装

```typescript
// JWT検証ミドルウェアを実装
app.use(async (req, res, next) => {
  const token = req.headers.authorization?.split(' ')[1];
  // ... 検証ロジック
});

// 不安な箇所で /reviewing-with-claude
// → "トークン再利用攻撃への対策がない" と指摘
// → jtiクレームを追加
```

#### Step 3: 包括レビュー

```
実装完了後、/reviewing-parallel を実行

結果:
- Codex: トークンの有効期限チェックがない → 修正
- CodeRabbit: エラーメッセージに機密情報 → 修正
- Copilot: レート制限がない → TODO追加
- Gemini: ログにトークンが出力される → 修正
```

---

## チェックリスト

実装開始前：

- [ ] ユーザーの要件は明確か？（曖昧ならAskUserQuestion）
- [ ] 設計判断が必要か？（必要なら/ask-peer）
- [ ] TDDの準備はできているか？（テスト環境のセットアップ）

実装中：

- [ ] 不安な箇所は/reviewing-with-claudeでチェックしたか？
- [ ] テストは全て通っているか？
- [ ] 実環境で動作確認したか？

実装後：

- [ ] 重要な変更なら/reviewing-parallelでレビューしたか？
- [ ] 全てのフィードバックに対応したか？
- [ ] ドキュメントは更新したか？
- [ ] コミットメッセージは適切か？

---

## 参考資料

- Claude Code公式ドキュメント: AskUserQuestionツール
- `/ask-peer` スキルのドキュメント
- `/reviewing-with-claude` スキルのドキュメント
- `/reviewing-parallel` スキルのドキュメント
