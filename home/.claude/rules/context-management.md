# コンテキスト管理とSSCIフレームワーク

## 概要

Claude Codeのコンテキストウィンドウ（200k トークン）を効率的に活用するための戦略的管理手法。
SSCIフレームワークに基づく情報圧縮と、戦略的コンパクト化により、長期セッションでも高品質な出力を維持する。

---

## SSCIフレームワーク

コンテキストを効率的に管理する4段階アプローチ。

### S - Summarize（要約）

**目的:** 大量の情報を本質的な要素に圧縮する

**適用場面:**
- 長文ドキュメント（100ページのPDF、技術仕様書）
- 大規模なログファイル
- 複数の調査結果

**手法:**

```
悪い例:
- PDFファイル全体をReadして貼り付け（10万トークン消費）

良い例:
- WebFetchやTaskエージェントで要約を依頼
- "重要な変更点を3つの箇条書きにまとめて"
- 結果: 数百トークンに圧縮
```

**実践:**

```typescript
// NG: 全文読み込み
Read({ file_path: "massive-changelog.md" });

// OK: 要約タスク
Task({
  subagent_type: "general-purpose",
  prompt: "changelog.mdの重要な破壊的変更を3点に要約",
  description: "Changelog要約"
});
```

---

### S - Select（選択）

**目的:** 必要な情報だけを選択的に読み込む

**適用場面:**
- 大規模なコードベース探索
- 特定機能の理解
- ドキュメントの一部だけが必要な場合

**手法:**

```
悪い例:
- src/ ディレクトリ全体をRead（数万トークン）

良い例:
- Grepで関連ファイルを特定
- 必要なファイルだけRead
- offsetとlimitで部分読み込み
```

**実践:**

```typescript
// NG: 全ファイル読み込み
Glob({ pattern: "src/**/*.ts" });
// 各ファイルをRead → コンテキスト爆発

// OK: 選択的読み込み
Grep({
  pattern: "authentication",
  output_mode: "files_with_matches"
});
// → 該当ファイルだけRead
```

---

### C - Compress（圧縮）

**目的:** 冗長な情報を削除し、本質だけを残す

**適用場面:**
- 繰り返しの多いログ
- 似たようなコード例
- テストケースの大量出力

**手法:**

```
悪い例:
- 1000行のテストログをそのまま貼り付け

良い例:
- エラーメッセージと該当箇所だけ抽出
- 重複を排除
- 代表的な1例だけ提示
```

**実践:**

```bash
# NG: 全ログ出力
npm test 2>&1 | tee test-output.log
# → 数千行のログ

# OK: エラーだけ抽出
npm test 2>&1 | grep -A 5 "FAIL"
# → 失敗したテストとその周辺のみ
```

---

### I - Isolate（分離）

**目的:** 独立したタスクをサブエージェントに分離する

**適用場面:**
- 並列実行可能なタスク
- 専門的な調査（技術選定、セキュリティ監査）
- 長時間かかる探索タスク

**手法:**

```
悪い例:
- メインセッションで全ての調査を実行
- コンテキストが肥大化

良い例:
- Taskエージェントに調査を委託
- 結果だけメインセッションに統合
- run_in_background で並列実行
```

**実践:**

```typescript
// NG: メインセッションで全部やる
Grep({ pattern: "security vulnerabilities" });
Read({ file_path: "security-audit.md" });
WebFetch({ url: "...", prompt: "..." });
// → コンテキスト消費大

// OK: サブエージェントに分離
Task({
  subagent_type: "general-purpose",
  prompt: "セキュリティ脆弱性を調査し、3点に要約",
  description: "セキュリティ監査",
  run_in_background: true
});
// → 結果だけ受け取る
```

---

## 戦略的コンパクト化

### コンパクトとは

Claude Codeの会話履歴を圧縮し、コンテキストウィンドウを節約する機能。

**メカニズム:**
- 過去の会話を要約して圧縮
- 重要な情報は保持
- トークン使用量を削減

**トレードオフ:**
- メリット: コンテキストウィンドウを節約
- デメリット: 過去の詳細が失われる可能性

---

### 自動コンパクトの無効化推奨

**理由:**
- 自動コンパクトは任意のタイミングで発火
- 作業の論理的な区切りと一致しない
- 重要な情報が失われるリスク

**設定方法:**

```json
// ~/.claude/settings.json
{
  "autoCompact": false
}
```

---

### 手動コンパクトの4つのタイミング

#### 1. 探索フェーズ終了後

**シナリオ:**
- コードベース探索が完了
- 実装に必要な情報を特定
- これから実装フェーズに入る

**実行タイミング:**
```
探索: 複数のGrep、Read、調査
→ 探索完了（必要なファイルを特定）
→ 【/context compact】
→ 実装開始
```

**理由:**
- 探索中の試行錯誤は実装後不要
- 実装に必要な情報だけ保持

---

#### 2. マイルストーン完了後

**シナリオ:**
- 大きな機能が完成
- テストが通過
- 次の機能に移る

**実行タイミング:**
```
機能A実装完了 → テスト通過 → コミット
→ 【/context compact】
→ 機能B実装開始
```

**理由:**
- 完了した機能の詳細は不要
- 次の機能に集中

---

#### 3. エラー解決後

**シナリオ:**
- 複雑なエラーを解決
- 多くの試行錯誤があった
- デバッグログが大量

**実行タイミング:**
```
エラー発生 → 調査 → 試行錯誤（10回以上）
→ 解決 → テスト通過
→ 【/context compact】
→ 次のタスク
```

**理由:**
- 失敗した試行は不要
- 解決策だけ保持

---

#### 4. コンテキスト使用量が60%を超えたら

**確認方法:**
```
/context
```

**実行基準:**
- 60%以上: コンパクト化を検討
- 80%以上: 即座にコンパクト化
- 90%以上: /clearして新しいセッション

**実行タイミング:**
```
/context → 使用量: 120k/200k (60%)
→ 論理的な区切りでコンパクト化を実行
```

---

### コンパクト化のチェックリスト

コンパクト実行前に確認:

- [ ] 現在のタスクは完了しているか？
- [ ] 過去の詳細が失われても問題ないか？
- [ ] 次のタスクに必要な情報は保持されているか？
- [ ] コミット・PRは作成済みか？

---

## /clearと/compactの使い分け

| コマンド | 効果 | 使用場面 |
|----------|------|----------|
| `/context compact` | 会話履歴を要約圧縮 | 論理的な区切り、60%超過時 |
| `/clear` | 会話履歴を完全削除 | 無関係なタスク間、2回失敗後 |

### /clearを使うべき場面

#### 1. キッチンシンク・セッション回避

**症状:**
- 無関係な複数タスクを同じセッションで実行
- コンテキストが混在

**対策:**

```
タスクA（認証機能）完了
→ 【/clear】
→ タスクB（決済機能）開始
```

#### 2. 繰り返しの修正

**症状:**
- 同じエラーを2回以上修正しても解決しない
- AIが混乱している

**対策:**

```
試行1: 失敗
試行2: 失敗
→ 【/clear】
→ 問題を再定義して再スタート
```

**ルール:**
> **2回失敗したら/clear**

---

## 実践例

### シナリオ1: REST API実装

```
1. 探索フェーズ
   - Grepで既存APIを調査
   - Readで実装パターンを確認
   - 使用量: 30k/200k (15%)

2. 探索完了 → /context compact
   - 使用量: 10k/200k (5%)

3. 実装フェーズ
   - 新規エンドポイント実装
   - テスト作成
   - 使用量: 50k/200k (25%)

4. 実装完了 → /context compact
   - 使用量: 15k/200k (7.5%)

5. 次の機能へ
```

---

### シナリオ2: エラーデバッグ

```
1. エラー発生
   - ログ確認（大量）
   - スタックトレース解析
   - 使用量: 40k/200k (20%)

2. 試行錯誤
   - 10回の修正試行
   - 使用量: 100k/200k (50%)

3. 解決 → /context compact
   - 使用量: 20k/200k (10%)
```

---

### シナリオ3: 無関係なタスク

```
1. タスクA: 認証機能実装
   - 使用量: 60k/200k (30%)

2. タスクA完了 → /clear
   - 使用量: 0k/200k (0%)

3. タスクB: デザインシステム構築
   - 完全に新しいコンテキストで開始
```

---

## よくある失敗パターンと対策

### パターン1: コンパクト化せずに進める

**症状:**
- コンテキストが90%を超える
- AIの応答が遅くなる
- 品質が低下

**対策:**

```
定期的に /context で確認
60%超過 → 論理的な区切りでコンパクト化
```

---

### パターン2: 無関係なタスクを同じセッションで実行

**症状:**
- 認証とデザインシステムを同じセッションで
- AIが混乱

**対策:**

```
タスク間で /clear を実行
```

---

### パターン3: 繰り返し失敗を放置

**症状:**
- 同じエラーを3回以上修正
- 解決しない

**対策:**

```
2回失敗 → /clear
問題を再定義
```

---

## チェックリスト

セッション開始前:

- [ ] 自動コンパクトを無効化している
- [ ] 前回のセッションは無関係か？（無関係なら/clear）

作業中:

- [ ] 定期的に/contextでコンテキスト使用量を確認
- [ ] 60%超過時にコンパクト化を検討

論理的な区切り:

- [ ] 探索完了後にコンパクト化
- [ ] マイルストーン完了後にコンパクト化
- [ ] エラー解決後にコンパクト化

---

---

## 並列作業の管理

### Git Worktrees活用

複数のClaudeインスタンスが同じコードベースを編集する場合、Git Worktreesでコンフリクトを回避。

#### シナリオ

```
同時作業:
- インスタンス1: 認証機能実装（feature-auth）
- インスタンス2: UI改善（feature-ui）
- インスタンス3: パフォーマンス最適化（feature-perf）
```

#### セットアップ

```bash
# メインリポジトリ
cd ~/projects/myapp

# feature-a用のworktree作成
git worktree add ../myapp-feature-a feature-a

# feature-b用のworktree作成
git worktree add ../myapp-feature-b feature-b

# feature-c用のworktree作成
git worktree add ../myapp-feature-c feature-c
```

#### 使用方法

```bash
# 各Claudeインスタンスで別のディレクトリを開く
cd ~/projects/myapp-feature-a  # インスタンス1
cd ~/projects/myapp-feature-b  # インスタンス2
cd ~/projects/myapp-feature-c  # インスタンス3
```

#### メリット

- コンフリクト回避
- 並列作業の効率化
- ブランチ切り替え不要

#### 注意事項

- ディスク容量を消費（各worktreeがコピー）
- 作業完了後はworktreeを削除

```bash
# worktree削除
git worktree remove ../myapp-feature-a
```

---

### カスケードパターン（タブ管理）

複数のClaudeインスタンスを効率的に管理するパターン。

#### ルール

1. **新しいタスクは右に新しいタブで開く**
   - タスクの時系列が視覚的に分かる

2. **左から右へスイープ**
   - 古いタスクから順に確認・完了
   - 左から右へ進む

3. **同時に3-4タスク以上は持たない**
   - それ以上はコンテキストスイッチが非効率
   - 古いタスクを完了させてから新規タスク開始

#### 実践例

```
タブ1: 認証実装（完了）→ 閉じる
タブ2: UI改善（進行中）
タブ3: パフォーマンス最適化（待機中）
→ タブ2を完了させてから新規タスクを追加
```

#### チェックリスト

- [ ] タブは左から右に時系列順か？
- [ ] 4タブ以上開いていないか？
- [ ] 古いタブから順に完了させているか？

---

## 参考資料

- Claude Code公式ドキュメント: `/context`コマンド
- FabyΔ「Claude Code 超完全ガイド」: SSCIフレームワーク、Git Worktrees、カスケードパターン
