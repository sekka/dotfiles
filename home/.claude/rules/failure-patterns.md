# よくある失敗パターンと対策

## 概要

Claude Code使用時に陥りやすい失敗パターンと、その対策をまとめる。
同じミスを繰り返さないための具体的なアクションプランを提供する。

---

## パターン1: キッチンシンク・セッション

### 症状

- 無関係な複数タスクを同じセッションで実行
- コンテキストが混在し、AIが混乱
- "認証機能を実装して" → "次にデザインシステムを作って" → "ついでに決済機能も"

**具体例:**

```
セッション開始
→ タスクA: ユーザー認証実装（40k トークン）
→ タスクB: UIデザインシステム（50k トークン）
→ タスクC: 決済API実装（60k トークン）
→ コンテキスト爆発（150k/200k）
→ AIが過去の文脈を混同
```

### 原因

- タスク間で `/clear` を実行しない
- "もったいない" という心理（セッション再開の手間）
- 無関係なタスクを連続実行

### 対策

#### ルール: 無関係なタスク間で `/clear`

```
タスクA完了
→ 【/clear】
→ タスクB開始
```

#### 判断基準: タスクは無関係か？

| 質問 | YES → /clear | NO → 継続 |
|------|-------------|----------|
| タスクBはタスクAの成果物に依存？ | 依存しない | 依存する |
| コードベースの異なる領域？ | 完全に別 | 同じ領域 |
| タスクAの文脈がタスクBに必要？ | 不要 | 必要 |

**例:**

```
OK（継続）:
- 認証API実装 → 認証UIコンポーネント実装
  （同じ機能、依存あり）

NG（/clear必要）:
- 認証API実装 → デザインシステム構築
  （完全に別の領域、依存なし）
```

#### チェックリスト

新しいタスクを始める前:

- [ ] 前のタスクは完全に完了しているか？
- [ ] 新しいタスクは前のタスクに依存しているか？
- [ ] コンテキストは新しいタスクに不要か？

**1つでも「依存していない」「不要」なら `/clear` を実行**

---

## パターン2: 繰り返しの修正（無限ループ）

### 症状

- 同じエラーを何度も修正しても解決しない
- AIが同じアプローチを繰り返す
- "修正しました" → テスト失敗 → "再度修正しました" → 失敗

**具体例:**

```
試行1: "この行を修正しました" → テスト失敗
試行2: "別の箇所を修正しました" → テスト失敗
試行3: "さらに別の箇所を..." → テスト失敗
試行4: ... （以下繰り返し）
```

### 原因

- AIが過去の失敗から学習できていない
- コンテキストに失敗の履歴が蓄積
- 問題の根本原因が特定できていない

### 対策

#### ルール: 2回失敗したら `/clear`

```
試行1: 失敗
試行2: 失敗
→ 【/clear】
→ 問題を再定義して再スタート
```

#### 再スタート時のアプローチ

1. **問題の再定義**

```
悪い再スタート:
"さっきのエラーを直して"

良い再スタート:
"テストが失敗する理由を調査してください。
 エラーメッセージ: [具体的なメッセージ]
 期待される動作: [具体的に]
 実際の動作: [具体的に]"
```

2. **異なるアプローチを要求**

```typescript
// 新しいセッションで
AskUserQuestion({
  questions: [{
    question: "どのアプローチで解決しますか？",
    header: "アプローチ",
    options: [
      {
        label: "デバッグログで原因特定",
        description: "console.logやデバッガーで状態を確認"
      },
      {
        label: "テストケースの追加",
        description: "失敗する最小ケースを特定"
      },
      {
        label: "別のライブラリを検討",
        description: "現在の実装を見直す"
      }
    ],
    multiSelect: false
  }]
});
```

#### チェックリスト

2回失敗後:

- [ ] `/clear` を実行したか？
- [ ] 問題を具体的に再定義したか？
- [ ] 異なるアプローチを試すか？
- [ ] 必要ならWebFetchやContext7で調査したか？

---

## パターン3: CLAUDE.md肥大化

### 症状

- CLAUDE.mdが数千行に膨れ上がる
- "念のため" と詳細すぎる指示を追加
- AIが重要な指示を見落とす

**具体例:**

```markdown
# CLAUDE.md（3000行）

## コーディング規約
- 変数名はcamelCase
- インデントは2スペース
- セミコロンは必須
- ... （100行以上の詳細ルール）

## テスト戦略
- テストカバレッジは80%以上
- ... （200行以上）

## デプロイ手順
- ... （500行）
```

### 原因

- "全て書いておけば安心" という心理
- 削除への恐怖（"これを消したらミスするかも"）
- 既存のルールファイルへの参照を使わない

### 対策

#### ルール: 各行について自問

> 「この行を削除したらClaude Codeがミスをするか？」

**削除すべき:**
- 一般的なベストプラクティス（AIは既に知っている）
- プロジェクト固有でない指示
- 重複している内容

**残すべき:**
- プロジェクト固有の制約
- チーム独自の規約
- 重要なコンテキスト

#### `@構文` で参照に置き換え

**Before:**

```markdown
# CLAUDE.md

## TDD
1. テストを先に書く
2. 最小限の実装
3. 実環境確認
... （50行）
```

**After:**

```markdown
# CLAUDE.md

## 参考資料

- TDD ワークフロー: `@.claude/rules/tdd-workflow.md`
```

#### スリム化のチェックリスト

- [ ] 一般的なベストプラクティスは削除
- [ ] 重複している指示は統合
- [ ] ルールファイルへの参照に置き換え
- [ ] プロジェクト固有の情報だけ残す

**目標行数:**
- CLAUDE.md: 200行以内
- 詳細はルールファイルに分離

---

## パターン4: 信頼→検証のギャップ

### 症状

- AIの出力を検証せずに信頼
- "修正しました" → 実際には動かない
- テストをスキップ

**具体例:**

```
AI: "脆弱性を修正しました"
ユーザー: "ありがとう！" → コミット
→ 実際には修正されていない
```

### 原因

- AIへの過度な信頼
- 検証の手間を省略
- TDDを実践していない

### 対策

#### ルール: 常に検証を提供

**AIの出力後、必ず実行:**

1. **テストを実行**

```bash
npm test
```

2. **実環境で動作確認**

```bash
# 開発サーバーを起動
npm run dev
# ブラウザで確認
```

3. **セキュリティチェック**

```bash
npm audit
```

#### チェックリスト

AIが "完了" と言った後:

- [ ] テストが全て通るか？
- [ ] 実環境で動作するか？
- [ ] エラーログに警告はないか？
- [ ] セキュリティ脆弱性はないか？

---

## パターン5: 無限探索

### 症状

- コードベース探索が終わらない
- "もう少し調べてから実装" → 永遠に実装しない
- スコープが拡大し続ける

**具体例:**

```
探索1: auth/ ディレクトリを調査
探索2: middleware/ も見ておこう
探索3: utils/ も関連するかも
探索4: ... （以下繰り返し）
→ コンテキスト爆発、実装未着手
```

### 原因

- 完璧主義（"全て理解してから"）
- スコープの曖昧さ
- サブエージェントを使わない

### 対策

#### ルール1: スコープを狭める

**探索前に明確化:**

```typescript
AskUserQuestion({
  questions: [{
    question: "どこまで調査しますか？",
    header: "スコープ",
    options: [
      {
        label: "必要最小限（実装に直接関係する箇所のみ）",
        description: "推奨: 素早く実装開始"
      },
      {
        label: "中程度（関連する周辺コードも）",
        description: "バランス型"
      },
      {
        label: "徹底的（全体のアーキテクチャ理解）",
        description: "リファクタリング時のみ推奨"
      }
    ],
    multiSelect: false
  }]
});
```

#### ルール2: サブエージェントに分離

**探索タスクを委託:**

```typescript
Task({
  subagent_type: "Explore",
  prompt: "認証関連のコードを調査し、3点に要約",
  description: "認証コード探索"
});
```

#### チェックリスト

探索中:

- [ ] スコープは明確か？
- [ ] 実装に必要な情報は揃ったか？
- [ ] 60分以上探索しているか？（YES→実装開始）

**ルール: 探索は実装時間の1/3以下**

```
例: 3時間の実装タスク
→ 探索は最大1時間
```

---

## パターン6: モデル選択ミス

### 症状

- 簡単なタスクにOpusを使い、コスト増
- 複雑なタスクにHaikuを使い、品質低下

**具体例:**

```
NG:
- "変数名をリネーム" → Opus（オーバースペック）
- "セキュリティ監査" → Haiku（アンダースペック）
```

### 原因

- モデル選択の基準が不明確
- デフォルトのSonnetを盲目的に使用

### 対策

#### モデル選択ガイドライン

| モデル | 用途 | 判断基準 |
|--------|------|----------|
| **Haiku** | 反復タスク、明確な指示 | ワーカーエージェント、単純作業 |
| **Sonnet** | 一般的なコーディング | 90%のタスクで使用 |
| **Opus** | 設計、セキュリティ、アーキテクチャ | 初回失敗時、5ファイル以上変更、重要な判断 |

#### Opusにアップグレードすべき場面

- [ ] 最初の試行が失敗
- [ ] 5ファイル以上の変更が必要
- [ ] アーキテクチャの意思決定
- [ ] セキュリティクリティカル
- [ ] 複雑なリファクタリング

#### Haikuにダウングレードすべき場面

- [ ] 反復的なタスク（テスト生成、ドキュメント整形）
- [ ] 指示が非常に明確
- [ ] マルチエージェントのワーカー

---

## 実践例

### シナリオ1: キッチンシンク回避

```
タスクA: 認証API実装
→ 完了
→ 【/clear】
→ タスクB: デザインシステム構築
```

---

### シナリオ2: 無限ループ脱出

```
試行1: エラー修正 → 失敗
試行2: 別の修正 → 失敗
→ 【/clear】
→ 問題を再定義:
   "エラーメッセージ: [具体的に]
    期待動作: [具体的に]
    実際の動作: [具体的に]"
→ デバッグログで原因特定
→ 解決
```

---

### シナリオ3: CLAUDE.mdスリム化

```
Before: 3000行

削除:
- 一般的なベストプラクティス（-1500行）
- 重複している指示（-500行）

参照に置き換え:
- TDD → @.claude/rules/tdd-workflow.md
- セキュリティ → @.claude/rules/security.md

After: 200行
```

---

## チェックリスト

セッション開始前:

- [ ] 前回のタスクは無関係か？（YES→/clear）
- [ ] CLAUDE.mdは200行以内か？

作業中:

- [ ] 2回失敗したか？（YES→/clear）
- [ ] 探索が1時間を超えたか？（YES→実装開始）
- [ ] AIの出力を検証したか？

セッション終了前:

- [ ] テストが全て通るか？
- [ ] 実環境で動作確認したか？
- [ ] コミットメッセージは適切か？

---

## 参考資料

- FabyΔ「Claude Code 超完全ガイド」: 失敗パターン
- コンテキスト管理: `@.claude/rules/context-management.md`
- TDDワークフロー: `@.claude/rules/tdd-workflow.md`
