---
name: asking-peer
description: 設計・実装方針について「同僚エンジニア」役のAIに相談します。レビューではなく、実装前の意思決定支援や複数アプローチの比較検討に使用します。現在のコンテキストを保持したまま対話的に相談できます。
allowed-tools: Task, Read, Grep, Glob, AskUserQuestion
---

# Peer Consultation（ピア相談）スキル

実装前の設計判断や方針決定について、別の視点を持つ「同僚エンジニア」役のAIに相談するスキルです。

## 使用場面

### ✅ このスキルを使うべき場面

- **設計判断**: 複数のアプローチがあり、どれを選ぶか迷っている
- **アーキテクチャ選択**: ライブラリ、フレームワーク、パターンの選定
- **トレードオフ評価**: パフォーマンス vs 可読性、柔軟性 vs シンプルさなど
- **リファクタリング方針**: どのようにコードを改善すべきか
- **実装前の確認**: "この方向性で大丈夫か"という確認

### ❌ このスキルが不適切な場面

- **コードレビュー**: 既に書いたコードの問題点指摘 → `/reviewing-with-claude` または `/reviewing-parallel` を使用
- **バグ修正**: エラーの原因特定と修正 → `/debug` を使用
- **情報収集**: ライブラリの使い方やAPIの調査 → Context7やWebFetchを使用

## 他の手段との使い分け

| スキル | 用途 | タイミング |
|-------|------|-----------|
| **asking-peer**（本skill） | 設計・方針の相談 | 実装前 |
| reviewing-with-claude | 軽量なコードレビュー | 実装中・実装後 |
| reviewing-parallel | 包括的な多角レビュー | 実装完了後 |
| Task (Plan agent) | 実装計画の立案 | プロジェクト開始時 |

## 相談の進め方

### Phase 0: ユーザーへの質問による明確化（AskUserQuestion）

**重要**: Peer相談の前に、必ずAskUserQuestionツールで要件を明確化すること。

ユーザーの最初の相談は曖昧な場合が多いため、以下の観点で質問を投げかける：

#### 質問すべき観点

1. **最優先事項**
   ```
   Question: "このプロジェクトで最も重視する要素は何ですか？"
   Options:
   - パフォーマンス（実行速度・メモリ効率）
   - 保守性（コードの読みやすさ・変更容易性）
   - 開発速度（素早くリリースすることが最優先）
   - スケーラビリティ（将来の拡張性）
   ```

2. **制約条件**
   ```
   Question: "プロジェクトの制約条件はありますか？"
   Options:
   - 厳しい納期がある
   - チームメンバーのスキルセットに制限がある
   - 既存システムとの互換性が必須
   - 特定の技術スタックに縛られている
   ```

3. **リスク許容度**
   ```
   Question: "新しい技術やアプローチの採用についてどう考えますか？"
   Options:
   - 積極的に採用したい（学習コストを許容）
   - 実績のある技術を優先したい
   - チームが既に知っている技術のみ使いたい
   ```

4. **スコープ**
   ```
   Question: "今回の変更の影響範囲はどの程度ですか？"
   Options:
   - 小規模（1つのモジュール内で完結）
   - 中規模（複数モジュールに影響）
   - 大規模（アーキテクチャ全体に影響）
   ```

**AskUserQuestion使用のガイドライン**:
- 自明な質問は避ける（例: "良いコードを書きたいですか？"）
- ユーザー自身が言語化していない前提を引き出す
- 選択肢は2-4個に絞る（多すぎると選択負担が増える）
- multiSelect: trueで複数選択を許可する場合もある

### Phase 1: 状況の整理

Phase 0で得た回答を基に、以下を整理：

1. **現在の状況**
   - どのような機能を実装しようとしているか
   - 既存のコードベース構造
   - 技術スタック

2. **検討中のアプローチ**
   - 選択肢A、B、C...
   - それぞれのメリット・デメリット（ユーザーが認識している範囲）

3. **制約条件**（Phase 0で明確化済み）
   - パフォーマンス要件
   - 保守性の優先度
   - チームのスキルセット
   - 既存コードとの整合性

### Phase 2: コンテキスト収集

必要に応じて以下の情報を収集：

```bash
# プロジェクト構造の把握
Glob: "**/*.{ts,js,py}" などで関連ファイル探索

# 既存パターンの確認
Grep: 類似実装を検索

# 依存関係の確認
Read: package.json, requirements.txt などを確認
```

### Phase 3: Peer Agent起動

Taskツールで「同僚エンジニア」役のagentを起動：

```
Task tool parameters:
- subagent_type: "general-purpose"
- description: "Peer consultation on design approach"
- prompt: 詳細なコンテキストと質問
```

**プロンプト構成例:**

```markdown
あなたは経験豊富なシニアエンジニアとして、同僚の設計判断を支援する立場です。

## プロジェクト状況
[プロジェクトの概要、技術スタック]

## 既存のコードベース
[関連する既存実装のパターン]

## 検討中の課題
[実装しようとしている機能の詳細]

## 検討しているアプローチ

### オプション1: [アプローチ名]
**概要**: ...
**メリット**: ...
**デメリット**: ...

### オプション2: [アプローチ名]
**概要**: ...
**メリット**: ...
**デメリット**: ...

## 制約条件
- パフォーマンス: [要件]
- 保守性: [優先度]
- 既存コードとの整合性: [考慮点]

## 相談内容

以下の観点から助言をお願いします：

1. **推奨アプローチ**: どのオプションを推奨するか、理由とともに
2. **見落としている点**: 考慮すべきだが見落としている観点はあるか
3. **代替案**: 提示したオプション以外に検討すべきアプローチはあるか
4. **リスク**: 各アプローチの潜在的なリスクと対策
5. **実装順序**: 段階的に実装する場合の推奨順序

**重要**:
- 単に「どちらも良い」という曖昧な回答は避けてください
- 具体的な理由と根拠を示して推奨してください
- トレードオフを明確にしてください
```

### Phase 4: 結果の統合

Peer agentからの回答を受け取り、以下の形式で整理して提示：

```markdown
## 🤝 Peer Consultation結果

### 📋 相談内容
[ユーザーの質問を要約]

### 💡 Peerの推奨
**推奨アプローチ**: [オプション名]

**理由**:
1. [理由1]
2. [理由2]
3. [理由3]

### ⚖️ トレードオフ分析

| 観点 | オプション1 | オプション2 | 推奨 |
|------|-----------|-----------|------|
| パフォーマンス | ⭐⭐⭐ | ⭐⭐ | オプション1 |
| 保守性 | ⭐⭐ | ⭐⭐⭐ | オプション2 |
| 実装コスト | 高 | 低 | オプション2 |

### ⚠️ 見落としていた観点
[Peerが指摘した新しい視点]

### 🔄 代替案
[提示されたオプション以外のアプローチ]

### 🚨 リスクと対策

**オプション1のリスク**:
- リスク: [内容]
- 対策: [対策案]

**オプション2のリスク**:
- リスク: [内容]
- 対策: [対策案]

### 📝 実装推奨順序
1. [ステップ1]
2. [ステップ2]
3. [ステップ3]

### 🎯 最終判断のヒント

Peerの推奨を踏まえて、以下を考慮して決定してください：

- あなたのプロジェクトで最優先すべき要素は何か？
- チームのスキルセットとマッチするか？
- 既存コードベースとの整合性は？
```

### Phase 5: 最終判断の委譲（AskUserQuestion）

Peer agentの分析結果を提示した後、**必ずAskUserQuestionで最終判断をユーザーに委ねる**。

#### 判断の委譲方法

Peerの推奨を提示した後、以下のような質問を行う：

```
Question: "Peerの分析を踏まえて、どのアプローチで進めますか？"
Options:
- Peerの推奨通り[オプション1]で進める
- [オプション2]の方が自分のプロジェクトに合っている
- 別のアプローチを検討したい（追加相談）
- もう少し詳しく[特定の観点]について知りたい
```

#### トレードオフが拮抗している場合

Peerが「どちらも一長一短」と判断した場合、より具体的な質問を行う：

```
Question: "パフォーマンスと保守性がトレードオフの関係にあります。この状況でどちらを優先しますか？"
Options:
- パフォーマンスを優先（後で保守性を改善する余地を残す）
- 保守性を優先（必要に応じてパフォーマンス最適化）
- 両立する別の方法を探す（追加調査）
```

#### 追加確認が必要な場合

ユーザーの回答が「詳しく知りたい」だった場合、焦点を絞った再相談を行う：

```
User選択: "セキュリティ観点でもう少し詳しく知りたい"
→ Peer agentをセキュリティに特化した相談内容で再起動
```

**重要な原則**:
- AIが勝手に判断しない（"オプション1で実装します"は禁止）
- 必ずユーザーに選択させる
- ユーザーが迷っている場合は、さらに質問を深掘りする

## 実装上の注意

### 1. AskUserQuestionの積極的使用（最重要）

このスキルの成否は、**AskUserQuestionをどれだけ効果的に使うか**にかかっている。

**使用タイミング**:
- Phase 0: 相談前の要件明確化（必須）
- Phase 5: 最終判断の委譲（必須）
- Phase 中: 曖昧な点が出てきたら随時質問

**良い質問の条件**:
- ユーザーが気づいていない前提を引き出す
- トレードオフを明確にする選択肢
- 選択肢は2-4個（多すぎない）
- "その他"を選択肢に含めない（自動的に追加される）

**避けるべき質問**:
- 自明な質問（"品質の高いコードを書きたいですか？"）
- 専門的すぎる質問（ユーザーが答えられない）
- はい/いいえで答えられる単純な質問（選択肢が少なすぎる）

### 2. コンテキストの引き継ぎ

- 現在のセッションで既に読み込んだコードは、Peer agentに渡す
- 大量のコードを全て渡すのではなく、関連部分のみを抽出

### 3. 中立性の維持

- Peer agentは特定のアプローチに偏らない
- トレードオフを客観的に提示
- 最終判断はユーザーに委ねる（AskUserQuestionで明示的に）

### 4. 鵜呑みにしない原則（重要）

**CLAUDE.mdに明記すべきルール**:

> Peer consultationの結果は、あくまで「別の視点からの意見」として扱い、鵜呑みにしない。
>
> - Mainセッション（あなた）の分析
> - Peer agentの意見
> - ユーザー自身の判断
>
> の3つを総合的に評価して、最終判断を下す。

### 5. 繰り返し相談

一度の相談で結論が出ない場合、Peerの回答を基にさらに質問を深掘りすることも可能：

**パターン1: AskUserQuestionで追加観点を確認**
```
AskUserQuestion: "Peerの推奨について、さらに確認したい観点はありますか？"
Options:
- セキュリティ観点での評価
- スケーラビリティの詳細分析
- 実装コストの見積もり
- 別のアプローチも検討したい
```

**パターン2: 再度Peer agentを起動**
```
User選択: "スケーラビリティの詳細分析"
→ スケーラビリティに特化したプロンプトでPeer agentを再起動
→ より深い分析結果を取得
→ 再度AskUserQuestionで最終判断を委譲
```

## 使用例

### 例1: 状態管理ライブラリの選定

```
User: Reactアプリの状態管理で、ReduxとZustandで迷っています

【Phase 0: 要件明確化】
AskUserQuestion: "このアプリの規模と優先事項を教えてください"
Options:
- 小規模アプリ、開発速度重視
- 中規模アプリ、保守性とのバランス
- 大規模アプリ、型安全性とスケーラビリティ重視

User選択: "中規模アプリ、保守性とのバランス"

【Phase 1-4: コンテキスト収集とPeer相談】
1. コンテキスト収集（既存のコード構造、チーム規模）
2. Peer agent起動
3. 両者のトレードオフ分析
4. プロジェクト特性に応じた推奨提示

【Phase 5: 最終判断】
AskUserQuestion: "Peerの分析では、あなたの状況ではZustandを推奨しています。どうしますか？"
Options:
- Zustandで進める（推奨）
- Reduxの方が良いと思う（理由を確認）
- 両方試して比較したい
```

### 例2: リファクタリング方針

```
User: 大きなコンポーネントをどう分割すべきか相談したい

【Phase 0: 制約確認】
AskUserQuestion: "リファクタリングの制約条件は？"
Options:
- 既存の動作を完全に維持する必要がある
- 一部機能追加も同時に行いたい
- 段階的に分割していきたい（動作中断を最小化）

User選択: "段階的に分割していきたい"

【Phase 1-4: 分析と提案】
1. 既存コンポーネントをRead
2. Peer agent起動（段階的分割のアプローチを重視）
3. 複数の分割パターンを提示（段階的実施可能性を考慮）
4. 保守性・再利用性・リスクの観点で評価

【Phase 5: ステップ選択】
AskUserQuestion: "Peerは3段階の分割を提案しています。どのステップから始めますか？"
Options:
- ステップ1: UIロジックの分離（リスク低）
- ステップ2: 状態管理の抽出（リスク中）
- ステップ3: API層の分離（リスク低）
- 全部まとめて実施（リスク高、時間短縮）
```

### 例3: パフォーマンス最適化

```
User: データフェッチをキャッシュすべきか、リアルタイムを優先すべきか

【Phase 0: ユースケース確認】
AskUserQuestion: "データの性質とユースケースを教えてください"
Options:
- 頻繁に変わるデータ（SNSのフィード的）
- たまに変わるデータ（設定、マスタデータ的）
- ほぼ静的なデータ（記事、ドキュメント的）

User選択: "たまに変わるデータ（設定、マスタデータ的）"

AskUserQuestion: "ユーザーの許容範囲は？（複数選択可）"
Options (multiSelect: true):
- 多少古いデータでも高速表示を優先
- データの整合性が最優先
- ネットワーク負荷の削減も重要

User選択: ["多少古いデータでも高速表示を優先", "ネットワーク負荷の削減も重要"]

【Phase 1-4: 戦略分析】
1. 現在の実装を確認
2. Peer agent起動（ユーザーの優先順位を考慮）
3. キャッシュ戦略の比較（SWR、React Query、手動管理等）
4. ユースケース別の推奨

【Phase 5: 戦略決定】
AskUserQuestion: "Peerの推奨はReact Query + 5分キャッシュです。採用しますか？"
Options:
- 推奨通り採用する
- キャッシュ時間を変更したい（1分/10分/30分）
- 別のキャッシュ戦略を検討したい
```

## エラーハンドリング

| シナリオ | 対処方法 |
|---------|---------|
| Peer agentがタイムアウト | 質問を簡略化して再実行 |
| 曖昧な推奨 | より具体的な制約を追加してリトライ |
| 矛盾する回答 | 矛盾点を指摘し、明確化を要求 |

## 期待される効果

1. **意思決定の質向上**: 多角的な視点で判断できる
2. **見落とし防止**: 自分では気づかなかった観点を発見
3. **学習効果**: Peerの思考プロセスから学べる
4. **心理的安心感**: "独りで判断"するプレッシャーの軽減

## 注意事項

- Peer agentは万能ではない。最終判断は必ずユーザーが行う
- 緊急時の判断には不向き（時間がかかる）
- トリビアルな判断には過剰（シンプルな選択は直感で決める方が良い）
